<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Sushi Shooter</title>
    <style>
        body {
            background-color: #222;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            color: white;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        canvas {
            background-color: #333;
            border: 4px solid #555;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            cursor: crosshair;
        }
    </style>
</head>
<body>

<canvas id="gameCanvas" width="400" height="600"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- НАСТРОЙКИ СУШИ ---
    
    // 1. Палитра начинок (без фиолетового, только реальные продукты)
    const SUSHI_COLORS = [
        '#4CAF50', // Огурец (Зеленый)
        '#FF9800', // Креветка (Оранжевый)
        '#FF7043', // Лосось (Коралловый)
        '#C62828', // Тунец (Красный)
        '#FDD835'  // Омлет (Желтый)
        // '#FFF9C4' // Рис (можно раскомментировать, если нужен белый)
    ];

    // 2. Параметры шариков
    const RADIUS = 20;            // Радиус шарика
    const DIAMETER = RADIUS * 2;
    const ROW_HEIGHT = RADIUS * Math.sqrt(3); // Для плотной упаковки (гексагональная сетка)
    
    // Переменные игры
    let grid = []; // Сетка шариков
    const rows = 10;
    const cols = 10; // В широком ряду
    
    // Текущий снаряд
    let bullet = {
        x: canvas.width / 2,
        y: canvas.height - RADIUS - 10,
        color: getRandomColor(),
        dx: 0,
        dy: 0,
        moving: false,
        speed: 10
    };

    // Состояние мыши
    let mouseX = 0;
    let mouseY = 0;

    // --- ИНИЦИАЛИЗАЦИЯ СЕТКИ ---
    function initGrid() {
        for (let r = 0; r < 5; r++) { // Заполняем первые 5 рядов
            let row = [];
            // Сдвиг для четных/нечетных рядов
            let currentCols = (r % 2 === 0) ? cols : cols - 1;
            
            for (let c = 0; c < currentCols; c++) {
                row.push({
                    x: 0, 
                    y: 0, 
                    color: getRandomColor(),
                    active: true
                });
            }
            grid.push(row);
        }
        // Остальные ряды пустые
        for (let r = 5; r < rows; r++) {
            grid.push([]); 
        }
    }

    // Вспомогательная: случайный цвет из списка
    function getRandomColor() {
        return SUSHI_COLORS[Math.floor(Math.random() * SUSHI_COLORS.length)];
    }

    // --- ОТРИСОВКА ---
    function drawBall(x, y, color) {
        ctx.beginPath();
        ctx.arc(x, y, RADIUS, 0, Math.PI * 2);
        
        // 1. Заливка цветом начинки
        ctx.fillStyle = color;
        ctx.fill();

        // 2. РИСУЕМ НОРИ (Черная обводка)
        ctx.lineWidth = 3;         // Толщина нори
        ctx.strokeStyle = '#000000'; // Цвет нори
        ctx.stroke();
        
        // (Опционально) Блик для объема
        ctx.beginPath();
        ctx.arc(x - RADIUS/3, y - RADIUS/3, RADIUS/4, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fill();
        ctx.closePath();
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Рисуем сетку
        for (let r = 0; r < grid.length; r++) {
            // Смещение для гексагональной сетки
            let offsetX = (r % 2 === 0) ? RADIUS : RADIUS * 2;
            
            for (let c = 0; c < grid[r].length; c++) {
                let ball = grid[r][c];
                if (ball.active) {
                    // Вычисляем координаты шарика в сетке
                    ball.x = offsetX + c * DIAMETER;
                    ball.y = RADIUS + r * ROW_HEIGHT;
                    
                    drawBall(ball.x, ball.y, ball.color);
                }
            }
        }

        // Рисуем снаряд (пушку)
        drawBall(bullet.x, bullet.y, bullet.color);

        // Линия прицела
        if (!bullet.moving) {
            ctx.beginPath();
            ctx.moveTo(bullet.x, bullet.y);
            ctx.lineTo(mouseX, mouseY); // Простая линия до курсора
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    // --- ЛОГИКА ---
    function update() {
        if (bullet.moving) {
            bullet.x += bullet.dx;
            bullet.y += bullet.dy;

            // Отскок от стен
            if (bullet.x - RADIUS < 0 || bullet.x + RADIUS > canvas.width) {
                bullet.dx *= -1;
            }

            // Столкновение с потолком
            if (bullet.y - RADIUS < 0) {
                snapToGrid();
            }

            // Столкновение с шариками
            for (let r = 0; r < grid.length; r++) {
                for (let c = 0; c < grid[r].length; c++) {
                    let b = grid[r][c];
                    if (b.active) {
                        let dist = Math.hypot(bullet.x - b.x, bullet.y - b.y);
                        if (dist < DIAMETER - 2) { // -2 для небольшой погрешности
                            snapToGrid();
                            return; // Прерываем цикл, так как снаряд остановился
                        }
                    }
                }
            }
        }
    }

    // Прилипание шарика к сетке
    function snapToGrid() {
        bullet.moving = false;

        // Определяем ближайшую ячейку
        let approxRow = Math.round((bullet.y - RADIUS) / ROW_HEIGHT);
        if (approxRow < 0) approxRow = 0;
        if (approxRow >= rows) approxRow = rows - 1;

        let offsetX = (approxRow % 2 === 0) ? RADIUS : RADIUS * 2;
        let approxCol = Math.round((bullet.x - offsetX) / DIAMETER);
        
        // Коррекция границ
        if (approxCol < 0) approxCol = 0;
        let maxCols = (approxRow % 2 === 0) ? cols : cols - 1;
        if (approxCol >= maxCols) approxCol = maxCols - 1;

        // Если ряд еще не существует (защита)
        if (!grid[approxRow]) grid[approxRow] = [];

        // Вставляем шарик в сетку
        // В реальной игре нужно сдвигать массив, если ячейка занята, но для простоты заменяем/добавляем
        // (Упрощенная логика прилипания для демо)
        let newBall = {
            x: 0, 
            y: 0, 
            color: bullet.color,
            active: true
        };
        
        // Простое добавление в структуру данных (нужна более сложная логика для идеального Bubbleshooter, но визуально сработает)
        if (grid[approxRow][approxCol] && grid[approxRow][approxCol].active) {
            // Если место занято, пытаемся найти соседнее (очень упрощенно)
            approxRow++; 
             if (!grid[approxRow]) grid[approxRow] = [];
        }
        
        // Расширяем массив, если нужно
        while(grid[approxRow].length <= approxCol) {
            grid[approxRow].push({active: false});
        }
        
        grid[approxRow][approxCol] = newBall;

        // ПЕРЕЗАРЯДКА
        bullet.x = canvas.width / 2;
        bullet.y = canvas.height - RADIUS - 10;
        bullet.color = getRandomColor();
        bullet.dx = 0;
        bullet.dy = 0;
    }

    // --- УПРАВЛЕНИЕ ---
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;
    });

    canvas.addEventListener('mousedown', (e) => {
        if (!bullet.moving) {
            let angle = Math.atan2(mouseY - bullet.y, mouseX - bullet.x);
            bullet.dx = Math.cos(angle) * bullet.speed;
            bullet.dy = Math.sin(angle) * bullet.speed;
            bullet.moving = true;
        }
    });

    // --- ЗАПУСК ---
    initGrid();
    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }
    loop();

</script>
</body>
</html>
